{"version":3,"sources":["webpack:///./node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack:///./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack:///./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack:///./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack:///./public/assets/js/modules/core/DpitStickyEvents.js","webpack:///./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"names":["_slicedToArray","arr","i","Array","isArray","_i","Symbol","iterator","_s","_e","_x","_r","_arr","_n","_d","call","next","Object","done","push","value","length","err","unsupportedIterableToArray","TypeError","ClassName","DpitStickyEvents","constructor","_ref","arguments","undefined","_ref$container","container","document","_ref$enabled","enabled","this","observers","stickyElements","state","Map","headerSentinels","footerSentinels","enableEvents","setState","sticky","get","headerSentinel","addSentinel","set","footerSentinel","isSticky","window","self","top","header","createHeaderObserver","footer","createFooterObserver","forEach","console","warn","disableEvents","fire","values","observer","disconnect","clear","addStickies","stickies","addSticky","className","sentinel","createElement","stickyParent","parentElement","style","cssText","classList","add","assign","left","position","right","visibility","insertBefore","getSentinelPosition","observe","appendChild","IntersectionObserver","_ref2","record","boundingClientRect","isIntersecting","rootBounds","target","stickyTarget","bottom","POSITION_TOP","threshold","HTMLDocument","root","_ref4","POSITION_BOTTOM","isSticking","dispatchEvent","CustomEvent","CHANGE","detail","bubbles","STUCK","UNSTUCK","stickyElement","stickyStyle","getComputedStyle","parentStyle","concat","getPropertyValue","height","parentPadding","parseInt","paddingTop","getBoundingClientRect","topSentinel","previousElementSibling","stickyOffset","topSentinelOffset","Math","round","abs","isSomeSticky","res","_arrayLikeToArray","len","arr2","_unsupportedIterableToArray","o","minLen","n","prototype","toString","slice","name","from","test"],"mappings":"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","file":"main/DpitStickyEvents-d81eace5.js","sourcesContent":["import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","\r\nconst ClassName = {\r\n\tSENTINEL: 'sticky-events--sentinel',\r\n\tSENTINEL_TOP: 'sticky-events--sentinel-top',\r\n\tSENTINEL_BOTTOM: 'sticky-events--sentinel-bottom',\r\n};\r\n\r\n\r\n// DpitStickyEvents class\r\n\r\nexport default class DpitStickyEvents {\r\n\t/**\r\n\t * Initialize a set of sticky elements with events\r\n\t *\r\n\t * @param {Element|Document} container\r\n\t * @param {boolean} enabled\r\n\t * @param {string} stickySelector\r\n\t */\r\n\r\n\tconstructor({ container = document, enabled = true } = {}) {\r\n\t\tthis.container = container;\r\n\t\tthis.observers = {};\r\n\t\tthis.stickyElements = [];\r\n\t\tthis.state = new Map();\r\n\t\tthis.headerSentinels = new Map();\r\n\t\tthis.footerSentinels = new Map();\r\n\r\n\t\tif (enabled) {\r\n\t\t\tthis.enableEvents();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Initialize the state for a sticky:\r\n\t * 1. Default isSticky to false\r\n\t * 2. Create and observe a header sentinel\r\n\t * 3. Create and observe a footer sentinel\r\n\t *\r\n\t * @param {HTMLElement|Node} sticky\r\n\t */\r\n\r\n\tsetState(sticky) {\r\n\t\tif (this.state.get(sticky)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst headerSentinel = this.addSentinel(sticky, ClassName.SENTINEL_TOP);\r\n\t\tthis.headerSentinels.set(headerSentinel, sticky);\r\n\r\n\t\tconst footerSentinel = this.addSentinel(sticky, ClassName.SENTINEL_BOTTOM);\r\n\t\tthis.footerSentinels.set(footerSentinel, sticky);\r\n\r\n\t\tthis.state.set(sticky, {\r\n\t\t\tisSticky: false,\r\n\t\t\theaderSentinel: headerSentinel,\r\n\t\t\tfooterSentinel: footerSentinel,\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Initialize the intersection observers on `.sticky` elements within the specified container.\r\n\t * Container defaults to `document`.\r\n\t */\r\n\r\n\tenableEvents() {\r\n\t\tif (window.self !== window.top) {\r\n\t\t\tconsole.warn('StickyEvents: There are issues with using IntersectionObservers in an iframe, canceling initialization. Please see https://github.com/w3c/IntersectionObserver/issues/183');\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Create IntersectionObservers for header and footer sentinels\r\n\r\n\t\tthis.observers = {\r\n\t\t\theader: this.createHeaderObserver(),\r\n\t\t\tfooter: this.createFooterObserver(),\r\n\t\t};\r\n\r\n\t\t// Then, initialize the sticky's state\r\n\r\n\t\tthis.stickyElements.forEach((sticky) => {\r\n\t\t\tthis.setState(sticky);\r\n\t\t});\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Reset the DOM to it's pre-sticky state.\r\n\t * 1. (Optionally) Fire a sticky-unstuck event on all stickies to reset them to their original unstuck state\r\n\t * 2. Disconnect and remove IntersectionObservers\r\n\t * 3. Clear out the global state\r\n\t *\r\n\t * @param {boolean} resetStickies\r\n\t */\r\n\r\n\tdisableEvents(resetStickies = true) {\r\n\t\tif (resetStickies) {\r\n\t\t\tthis.stickyElements.forEach(sticky => this.fire(false, sticky));\r\n\t\t}\r\n\r\n\t\tObject.values(this.observers).forEach(observer => observer.disconnect());\r\n\r\n\t\tthis.observers = null;\r\n\r\n\t\tthis.state.clear();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Add a list of stickies to the existing set\r\n\t *\r\n\t * @param {NodeList} stickies\r\n\t */\r\n\r\n\taddStickies(stickies) {\r\n\t\tthis.stickyElements.push(...stickies);\r\n\t\tthis.stickyElements.forEach(sticky => this.setState(sticky));\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Add a single sticky to the existing set\r\n\t *\r\n\t * @param {Node} sticky\r\n\t */\r\n\r\n\taddSticky(sticky) {\r\n\t\tthis.stickyElements.push(sticky);\r\n\t\tthis.setState(sticky);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Create and observe a sentinel for given sticky. Type of sentinel is determined by className.\r\n\t *\r\n\t * @param {HTMLElement} sticky\r\n\t * @param {string} className\r\n\t * @returns {Element}\r\n\t */\r\n\r\n\taddSentinel(sticky, className) {\r\n\t\tconst sentinel = document.createElement('div');\r\n\t\tconst stickyParent = sticky.parentElement;\r\n\r\n\t\t// Apply styles to the sticky element\r\n\r\n\t\tsticky.style.cssText = `\r\n\t\tposition: -webkit-sticky;\r\n\t\tposition: sticky;\r\n\t  `;\r\n\r\n\t\t// Apply default sentinel styles\r\n\r\n\t\tsentinel.classList.add(ClassName.SENTINEL, className);\r\n\r\n\t\tObject.assign(sentinel.style, {\r\n\t\t\tleft: 0,\r\n\t\t\tposition: 'absolute',\r\n\t\t\tright: 0,\r\n\t\t\tvisibility: 'hidden',\r\n\t\t});\r\n\r\n\t\tswitch (className) {\r\n\t\t\tcase ClassName.SENTINEL_TOP: {\r\n\t\t\t\tstickyParent.insertBefore(sentinel, sticky);\r\n\r\n\t\t\t\t// Apply styles specific to the top sentinel\r\n\r\n\t\t\t\tObject.assign(\r\n\t\t\t\t\tsentinel.style,\r\n\t\t\t\t\tthis.getSentinelPosition(sticky, sentinel, className),\r\n\t\t\t\t\t{ position: 'relative' },\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Observe the sentinel\r\n\r\n\t\t\t\tthis.observers.header.observe(sentinel);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase ClassName.SENTINEL_BOTTOM: {\r\n\t\t\t\tstickyParent.appendChild(sentinel);\r\n\r\n\t\t\t\t// Apply styles specific to the bottom sentinel\r\n\r\n\t\t\t\tObject.assign(sentinel.style, this.getSentinelPosition(sticky, sentinel, className));\r\n\r\n\t\t\t\t// Observe the sentinel\r\n\r\n\t\t\t\tthis.observers.footer.observe(sentinel);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn sentinel;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets up an intersection observer to notify `document` when elements with the `ClassName.SENTINEL_TOP` become\r\n\t * visible/hidden at the top of the sticky container.\r\n\t *\r\n\t * @returns {IntersectionObserver}\r\n\t */\r\n\r\n\tcreateHeaderObserver() {\r\n\t\treturn new IntersectionObserver(([record]) => {\r\n\t\t\tconst { boundingClientRect, isIntersecting, rootBounds } = record;\r\n\t\t\tconst stickyParent = record.target.parentElement;\r\n\t\t\tconst stickyTarget = this.headerSentinels.get(record.target);\r\n\r\n\t\t\tstickyParent.style.position = 'relative';\r\n\r\n\t\t\tif (boundingClientRect.bottom < rootBounds.bottom && isIntersecting) {\r\n\t\t\t\tthis.fire(false, stickyTarget, DpitStickyEvents.POSITION_TOP);\r\n\t\t\t}\r\n\r\n\t\t\telse if (boundingClientRect.bottom <= rootBounds.top && !isIntersecting) {\r\n\t\t\t\tthis.fire(true, stickyTarget, DpitStickyEvents.POSITION_TOP);\r\n\t\t\t}\r\n\t\t}, Object.assign({\r\n\t\t\tthreshold: 0,\r\n\t\t}, !(this.container instanceof HTMLDocument) && {\r\n\t\t\troot: this.container\r\n\t\t}));\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets up an intersection observer to notify `document` when elements with the `ClassName.SENTINEL_BOTTOM` become\r\n\t * visible/hidden at the bottom of the sticky container.\r\n\t *\r\n\t * @returns {IntersectionObserver}\r\n\t */\r\n\r\n\tcreateFooterObserver() {\r\n\t\treturn new IntersectionObserver(([record]) => {\r\n\t\t\tconst { boundingClientRect, isIntersecting, rootBounds } = record;\r\n\t\t\tconst stickyTarget = this.footerSentinels.get(record.target);\r\n\t\t\tif (boundingClientRect.top < rootBounds.top && boundingClientRect.bottom < rootBounds.bottom && !isIntersecting) {\r\n\t\t\t\tthis.fire(false, stickyTarget, DpitStickyEvents.POSITION_BOTTOM);\r\n\t\t\t}\r\n\r\n\t\t\telse if (boundingClientRect.bottom > rootBounds.top && this.isSticking(stickyTarget) && isIntersecting) {\r\n\t\t\t\tthis.fire(true, stickyTarget, DpitStickyEvents.POSITION_BOTTOM);\r\n\t\t\t}\r\n\t\t}, Object.assign({\r\n\t\t\tthreshold: 1,\r\n\t\t}, !(this.container instanceof HTMLDocument) && {\r\n\t\t\troot: this.container\r\n\t\t}));\r\n\t}\r\n\r\n\r\n\r\n\r\n\t/**\r\n\t * Dispatch the following events:\r\n\t * - `sticky-change`\r\n\t * - `sticky-stuck` or `sticky-unstuck`\r\n\t *\r\n\t * @param {Boolean} isSticky\r\n\t * @param {Element} stickyTarget\r\n\t * @param {DpitStickyEvents.POSITION_BOTTOM|DpitStickyEvents.POSITION_TOP} position\r\n\t */\r\n\r\n\tfire(isSticky, stickyTarget, position) {\r\n\t\tif (!stickyTarget) return;\r\n\t\tconst { isSticky: previouslySticky } = this.state.get(stickyTarget);\r\n\r\n\t\t// Don't fire any events if the new state is the same as the previous state\r\n\r\n\t\tif (previouslySticky === isSticky) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Update the sticky state\r\n\r\n\t\tthis.state.set(stickyTarget, { isSticky });\r\n\r\n\t\t// Fire some events if the state is changing\r\n\r\n\t\tstickyTarget.dispatchEvent(new CustomEvent(DpitStickyEvents.CHANGE, { detail: { isSticky, position }, bubbles: true }));\r\n\t\tstickyTarget.dispatchEvent(new CustomEvent(isSticky ? DpitStickyEvents.STUCK : DpitStickyEvents.UNSTUCK, { detail: { isSticky, position }, bubbles: true }));\r\n\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Determine the position of the sentinel\r\n\t *\r\n\t * @param {Element|Node} stickyElement\r\n\t * @param {Element|Node} sentinel\r\n\t * @param {String} className\r\n\t * @returns {Object}\r\n\t */\r\n\r\n\tgetSentinelPosition(stickyElement, sentinel, className) {\r\n\t\tconst stickyStyle = window.getComputedStyle(stickyElement);\r\n\t\tconst parentStyle = window.getComputedStyle(stickyElement.parentElement);\r\n\r\n\t\tswitch (className) {\r\n\t\t\tcase ClassName.SENTINEL_TOP:\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttop: `calc(${stickyStyle.getPropertyValue('top')} * -1)`,\r\n\t\t\t\t\theight: 1,\r\n\t\t\t\t};\r\n\r\n\t\t\tcase ClassName.SENTINEL_BOTTOM: {\r\n\t\t\t\tconst parentPadding = parseInt(parentStyle.paddingTop);\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbottom: stickyStyle.top,\r\n\t\t\t\t\theight: `${stickyElement.getBoundingClientRect().height + parentPadding}px`,\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Determine if the sticky element is currently sticking in the browser\r\n\t *\r\n\t * @param {Element} stickyElement\r\n\t * @returns {boolean}\r\n\t */\r\n\r\n\tisSticking(stickyElement) {\r\n\t\tif (!stickyElement) return false;\r\n\t\tconst topSentinel = stickyElement.previousElementSibling;\r\n\r\n\t\tconst stickyOffset = stickyElement.getBoundingClientRect().top;\r\n\t\tconst topSentinelOffset = topSentinel.getBoundingClientRect().top;\r\n\t\tconst difference = Math.round(Math.abs(stickyOffset - topSentinelOffset));\r\n\r\n\t\tconst topSentinelTopPosition = Math.abs(parseInt(window.getComputedStyle(topSentinel).getPropertyValue('top')));\r\n\r\n\t\treturn difference !== topSentinelTopPosition;\r\n\t}\r\n\r\n\r\n\tisSomeSticky() {\r\n\t\tlet res = false;\r\n\t\tthis.state.forEach((value) => {\r\n\t\t\tif (value.isSticky) {\r\n\t\t\t\tres = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn res;\r\n\t}\r\n}\r\n\r\n// Events\r\n\r\nDpitStickyEvents.CHANGE = 'sticky-change';\r\nDpitStickyEvents.STUCK = 'sticky-stuck';\r\nDpitStickyEvents.UNSTUCK = 'sticky-unstuck';\r\n\r\n// Position\r\n\r\nDpitStickyEvents.POSITION_BOTTOM = 'bottom';\r\nDpitStickyEvents.POSITION_TOP = 'top';","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"sourceRoot":""}